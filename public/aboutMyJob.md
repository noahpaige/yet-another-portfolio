Okay, so I'm going to go a bit off script here with phase 1. I want to give you a large amount of background on my current CACI job to help inform your edits.

I work for CACI as a web developer. I was hired out of college, following a 6 month internship at CACI. CACI has many products, mostly dealing with government contracts. My office focuses on a contract with the National Reconnaissance Office (NRO) of the US Government to support rocket launches. We provide 2 things: Independent Verification and Validation (of trajectory and other calculations), and situational awareness software. I work solely on the situational awareness software part.

The situation awareness software takes the form of a web app that we run and manage during NRO rocket launches. The app shows all kinds of info about the launch, like announcments, timelines, completed milestones, current issues, and a few 3D visualization displays. The front end of the app is made with Nodejs and Vue. The back end is made up of a collection of different languages, including fortran, c++, java, nodejs, and php, along with the Redis database. I primarily deal with the front end, but I do work on the back end as well. the split is about 60% front end, 40% back end. I feel like I am equally capable at both, but I have gravitated towards front end because I feel like that is the part of the app that is most lacking. When I do deal with the back end, I work with the java, nodejs, and php.

On the front end, I work on creating UIs, implementing new major features, and the 3D visualization displays (made with Three.js). I was originally hired to focus on 3D displays due to my experience with games and graphics, but over the years I have transitioned into more of a support role to our other 3D graphics dev on the team. I still enjoy working with 3D, but this is just how the responsibilities shook out on our team as I moved to fill a need in the UI/UX design department. As I moved away from 3D, I started working more on proposing and implementing major features to the software (see below for examples). Most recently, I have been working on many projects that involve creating full-stack apps on my own. A few are for internal use, but most are customer-facing.

Another large component of my job is supporting launches. Our office supports many launches per year, which include several practice launches leading up to the real thing. I am assigned to be the software lead of a launch about 4 times a year. When I am the software lead for a launch, I am responsible for creating a build of the software for the launch and configuring it to support the specific launch. The configuration process can be a quite lengthy process. We have to make certain configurations based on things like the launch provider (SpaceX, ULA, etc.), where the launch is taking place (usuall Vandenburg SFB or Cape Canaveral SFB), how many payloads are on the rocket, what model of rocket is being used, and more. During the launch (and practice launches), I am required to be in the operations room in the office, running the software and providing tech support to my coworkers and the customer. I would say that this takes up about 25% of my time at my job.

Now, I'll chronologically list all of the major projects I have worked while at CACI.

### 3D refactor

My first major task was to refactor our 3D code. There are a couple different displays that we have that are 3D, but they're all essentailly versions of the main one which is a 3D simulation of the rocket. It shows the rocket in relation to earth, including a nominal and actual path, events markers, and the current stage of the rocket. The 3D code was in a dire state! It was a 5000+ line monstrosity. I added structure, and separated it into several classes to represent the various components of the scene. Also, comments! I added made sure to add JSDoc comments to everything to hopefully help future developers. This project taught me the importance of comments, and that I had a lot to learn about orbital mechanics!

### image capture

Another project I worked on was to re-create the image capture software that we use leading up to and during launches. The image capture software takes screenshots of various displays throughout the launch to aid in bug-detection and provide a history of the launch. I created the app using Nodejs and the Puppeteer package (a web scraping tool). The app spins up a Chromium window, logs in to the web app, and navigates to different pages to take screenshots based on a pre-defined schedule. I created a quite robust scheduling system that supported the addition/subtraction of captures on the fly, as well as forward and backward time jumps. This project introduced me to web scraping and honed my skills with scheduling algoriths.

### launch feed

I proposed the launch feed feature about 3 years ago, and have continued to develop and support it since. After becoming more familiar with the codebase, I noticed that we did not have any kind of display that provided a summary of all that has been going on during the launch. So, I proposed the Launch Feed to fill this need. The Launch Feed is a Twitter-style display that shows posts (displayed chronologically) about everything that has been happening during the launch. It serves two purposes -- the first being a one-stop-shop kind of display. If you only have space for one display and want to be up to date on everything, then this is the one for you. The second purpose is to provide a history of what happened during the launch. Many of the displays show CURRENT information, but don't provide a history. Launch Feed provides a great way to either catch up mid-launch, or to go back and see what happened after the fact.

I was responsible for creating the front end and back end for this feature. On the front end, I really got to flex my UI/UX muscles and create something of my own. I focused on creating a more modern look and feel, but without straying so far that it didn't fit in with the rest of the app. I also put an emphasis on animation, as I believe that tasteful animation gives a premium feel to an app.

The back end work on this feature was quite complex. I designed Launch Feed to run on on the server and listen to changes to about fifteen different keys in our Redis database. Each peice of data has a different format, so I created custom logic that converted each key into a launch feed post. I also added a significant amount of logic for each peice of data that determined if the update is worthy of creating a new post or not. I conducted several demo sessions with the launch support team to refine this logic.

Developing Launch Feed gave me a lot of confidence in my skills. It was a long, yet gratifying process. I learned so much about Redis and databases in general. I'm particularly proud of the system design for this feature; it is readable and very easy to scale and maintain. I am also happy with how the UI turned out. It is a major improvement upon the rest of the app without being too over the top.

### rapds

I'm part of a small team that been working on-and-off on a separate launch software project for CACI. This project aims to provide a similar experience to the sofware that we create for the NRO, but with the main differentiator being that CACI owns the software. We use a similar tech stack of Vue, Node, and Redis, but without any of the legacy back-end code from the NRO version. In this project, we use Nodejs as our entire back end. For this project, we were able to bring on a UI/UX design team member. I worked full-stack on this app, working on back end code as well as implementing the UI created by our designer.

Also, I was the sole developer for the launcher app for this project. I created the app using Electron, node, vue, and tailwind. With this project, I learned about the importance of creating UI prototypes, got a crash course in creating apps with Electron, and I learned the how amazing tailwind is!

### predictive diagnostics

I contibuted to a project that uses machine learning to provide predictive diagnostics to hardware sensors. The idea is that this system will one day be deployed to various locations to remotely monitor the hardware and detect faults before they happen. This project uses a microservice architecture , including Kafka for message passing, Zookeeper for coordination, ClickHouse and Postgres for databases, and the Python Streamlit UI package. My job was improve the UI by adding the ability to render custom UI components and pages using React. Up until this point, all the codebases I have worked on have been monolithic, so working with a microservices architecture was certaintly a learning experience. Additionally, figuring out how to create custom components and pages with react and then integrate them into the existing Streamlit website was quite tough. Check out more info about it HERE TODO.

### new tech stack

Most recently, I've been working on a proof-of-concept project aimed at designing a modern version of our launch software. The front end of the current codebase was built over a decade ago, and parts of the back end are even older. This project has two main goals: first, to update the tech stack, as the existing codebase is several versions behind and difficult to upgrade; and second, to redesign the architecture using more standard patterns, making it easier for both new developers and LLMs to understand and work with.

I've been tasked with deciding the tech stack (Node, Redis, Vue, Tailwind, Shadcn components, Motion animations), and creating all the necessary back-end services including browser window management, telemetry data input, a Redis-based pub/sub message passing service, and a notification system -- with more to come! The old codebase is a SaaS project that has changed significantly since its creation, accumulating technical debt due to feature creep. With my redesign, I am able to design the new systems in a more clear and succinct way.

For the UI, I’m focused on creating a modern, cohesive design with a simpler, more unified visual language. This includes refining the color scheme to reinforce consistency and contribute to the overall polish. Drawing from my background in game design, I aim to make the UI/UX more juicy—that is, rich with satisfying visual and interactive feedback. Animation plays a key role in this approach. Almost every component is animated for common interactions such as hover, click, show, and hide. I believe this level of detail adds a sense of craftsmanship and quality to the interface.

This is the project with the largest scope that I have worked on, and that increased scope has opened my eyes to the importance high level systems design. For the back end, I am creating so many systems that all have to work together. Diagraming and conceptualizing how they all integrate together has been key.
